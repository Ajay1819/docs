(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{111:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){b(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),d=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=d(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,b=e.originalType,r=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=d(n),m=a,u=p["".concat(r,".").concat(m)]||p[m]||s[m]||b;return n?i.a.createElement(u,c(c({ref:t},l),{},{components:n})):i.a.createElement(u,c({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var b=n.length,r=new Array(b);r[0]=m;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,r[1]=c;for(var l=2;l<b;l++)r[l]=n[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},99:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return d}));var a=n(3),i=n(7),b=(n(0),n(111)),r={title:"v0.1"},c={unversionedId:"flashbots-core/miners/mev-geth-spec/v01",id:"flashbots-core/miners/mev-geth-spec/v01",isDocsHomePage:!1,title:"v0.1",description:"Simple Summary",source:"@site/docs/flashbots-core/miners/mev-geth-spec/v01.md",slug:"/flashbots-core/miners/mev-geth-spec/v01",permalink:"/flashbots-core/miners/mev-geth-spec/v01",version:"current",sidebar:"docs",previous:{title:"interacting with mev-relay",permalink:"/flashbots-core/miners/advanced/interacting-with-mev-relay"},next:{title:"v0.1 RPC",permalink:"/flashbots-core/miners/mev-geth-spec/v01-rpc"}},o=[{value:"Simple Summary",id:"simple-summary",children:[]},{value:"Abstract",id:"abstract",children:[]},{value:"Motivation",id:"motivation",children:[]},{value:"Specification",id:"specification",children:[{value:"Definitions",id:"definitions",children:[]},{value:"Bundle construction",id:"bundle-construction",children:[]},{value:"Accepting bundles from the network",id:"accepting-bundles-from-the-network",children:[]},{value:"Bundle eligibility",id:"bundle-eligibility",children:[]},{value:"Block construction",id:"block-construction",children:[]},{value:"Bundle eviction",id:"bundle-eviction",children:[]}]},{value:"Rationale",id:"rationale",children:[{value:"At most one MevBundle gets included in the block",id:"at-most-one-mevbundle-gets-included-in-the-block",children:[]}]},{value:"Each bundle needs a blockNumber",id:"each-bundle-needs-a-blocknumber",children:[]},{value:"Backwards Compatibility",id:"backwards-compatibility",children:[]},{value:"Security Considerations",id:"security-considerations",children:[]}],l={toc:o};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(b.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(b.b)("h2",{id:"simple-summary"},"Simple Summary"),Object(b.b)("p",null,"Defines the construction and usage of MEV bundles by the miners. Provides specification for custom implementation of required node changes so that MEV bundles can be used correctly."),Object(b.b)("h2",{id:"abstract"},"Abstract"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"MevBundles")," are stored by the node and the best bundle is added to the block in front of other transactions. ",Object(b.b)("inlineCode",{parentName:"p"},"MevBundles")," are sorted by their ",Object(b.b)("inlineCode",{parentName:"p"},"adjusted gas price"),"."),Object(b.b)("h2",{id:"motivation"},"Motivation"),Object(b.b)("p",null,"We believe that without the adoption of neutral, public, open-source infrastructure for permissionless MEV extraction, MEV risks becoming an insiders' game. We commit as an organisation to releasing reference implementations for participation in fair, ethical, and politically neutral MEV extraction."),Object(b.b)("h2",{id:"specification"},"Specification"),Object(b.b)("p",null,"The key words ",Object(b.b)("inlineCode",{parentName:"p"},"MUST"),", ",Object(b.b)("inlineCode",{parentName:"p"},"MUST NOT"),", ",Object(b.b)("inlineCode",{parentName:"p"},"REQUIRED"),", ",Object(b.b)("inlineCode",{parentName:"p"},"SHALL"),", ",Object(b.b)("inlineCode",{parentName:"p"},"SHALL NOT"),", ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD"),", ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD NOT"),", ",Object(b.b)("inlineCode",{parentName:"p"},"RECOMMENDED"),",  ",Object(b.b)("inlineCode",{parentName:"p"},"MAY"),", and ",Object(b.b)("inlineCode",{parentName:"p"},"OPTIONAL")," in this document are to be interpreted as described in ",Object(b.b)("a",{parentName:"p",href:"https://www.ietf.org/rfc/rfc2119.txt"},"RFC-2119"),"."),Object(b.b)("h3",{id:"definitions"},"Definitions"),Object(b.b)("h4",{id:"bundle"},Object(b.b)("inlineCode",{parentName:"h4"},"Bundle")),Object(b.b)("p",null,"A set of transactions that ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," be executed together and ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," be executed at the beginning of the block."),Object(b.b)("h4",{id:"unit-of-work"},Object(b.b)("inlineCode",{parentName:"h4"},"Unit of work")),Object(b.b)("p",null,"A ",Object(b.b)("inlineCode",{parentName:"p"},"transaction"),", a ",Object(b.b)("inlineCode",{parentName:"p"},"bundle")," or a ",Object(b.b)("inlineCode",{parentName:"p"},"block"),"."),Object(b.b)("h4",{id:"subunit"},Object(b.b)("inlineCode",{parentName:"h4"},"Subunit")),Object(b.b)("p",null,"A discernible ",Object(b.b)("inlineCode",{parentName:"p"},"unit of work")," that is a part of a bigger ",Object(b.b)("inlineCode",{parentName:"p"},"unit of work"),". A ",Object(b.b)("inlineCode",{parentName:"p"},"transaction")," is a ",Object(b.b)("inlineCode",{parentName:"p"},"subunit")," of a ",Object(b.b)("inlineCode",{parentName:"p"},"bundle")," or a ",Object(b.b)("inlineCode",{parentName:"p"},"block"),". A ",Object(b.b)("inlineCode",{parentName:"p"},"bundle")," is a ",Object(b.b)("inlineCode",{parentName:"p"},"subunit")," of a ",Object(b.b)("inlineCode",{parentName:"p"},"block"),"."),Object(b.b)("h4",{id:"total-gas-used"},Object(b.b)("inlineCode",{parentName:"h4"},"Total gas used")),Object(b.b)("p",null,"A sum of gas units used by each transaction from the ",Object(b.b)("inlineCode",{parentName:"p"},"unit of work"),"."),Object(b.b)("h4",{id:"average-gas-price"},Object(b.b)("inlineCode",{parentName:"h4"},"Average gas price")),Object(b.b)("p",null,"Sum of (",Object(b.b)("inlineCode",{parentName:"p"},"gas price")," * ",Object(b.b)("inlineCode",{parentName:"p"},"total gas used"),") of all ",Object(b.b)("inlineCode",{parentName:"p"},"subunits")," divided by the ",Object(b.b)("inlineCode",{parentName:"p"},"total gas used")," of the unit."),Object(b.b)("h4",{id:"direct-coinbase-payment"},Object(b.b)("inlineCode",{parentName:"h4"},"Direct coinbase payment")),Object(b.b)("p",null,"A value of a transaction with a recipient set to be the same as the ",Object(b.b)("inlineCode",{parentName:"p"},"coinbase")," address."),Object(b.b)("h4",{id:"contract-coinbase-payment"},Object(b.b)("inlineCode",{parentName:"h4"},"Contract coinbase payment")),Object(b.b)("p",null,"A payment from a smart contract to the ",Object(b.b)("inlineCode",{parentName:"p"},"coinbase")," address."),Object(b.b)("h4",{id:"profit"},Object(b.b)("inlineCode",{parentName:"h4"},"Profit")),Object(b.b)("p",null,"A difference between the balance of the ",Object(b.b)("inlineCode",{parentName:"p"},"coinbase")," account at the end and at the beginning of the execution of a ",Object(b.b)("inlineCode",{parentName:"p"},"unit of work"),". We can measure a ",Object(b.b)("inlineCode",{parentName:"p"},"transaction profit"),", a ",Object(b.b)("inlineCode",{parentName:"p"},"bundle profit"),", and a ",Object(b.b)("inlineCode",{parentName:"p"},"block profit"),"."),Object(b.b)("p",null,"Balance of the ",Object(b.b)("inlineCode",{parentName:"p"},"coinbase")," account changes in the following way"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:null},"Unit of work"),Object(b.b)("th",{parentName:"tr",align:null},"Balance Change"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},"Transaction"),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"average gas price")," * ",Object(b.b)("inlineCode",{parentName:"td"},"total gas used")," + ",Object(b.b)("inlineCode",{parentName:"td"},"direct coinbase payment"),"  + ",Object(b.b)("inlineCode",{parentName:"td"},"contract coinbase payment"))),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},"Bundle"),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"average gas price")," * ",Object(b.b)("inlineCode",{parentName:"td"},"total gas used")," + ",Object(b.b)("inlineCode",{parentName:"td"},"direct coinbase payment"),"  + ",Object(b.b)("inlineCode",{parentName:"td"},"contract coinbase payment"))),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},"Block"),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"block reward")," + ",Object(b.b)("inlineCode",{parentName:"td"},"average gas price")," * ",Object(b.b)("inlineCode",{parentName:"td"},"total gas used")," + ",Object(b.b)("inlineCode",{parentName:"td"},"direct coinbase payment"),"  + ",Object(b.b)("inlineCode",{parentName:"td"},"contract coinbase payment"))))),Object(b.b)("h4",{id:"adjusted-gas-price"},Object(b.b)("inlineCode",{parentName:"h4"},"Adjusted gas price")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"Unit of work")," ",Object(b.b)("inlineCode",{parentName:"p"},"profit")," divided by the ",Object(b.b)("inlineCode",{parentName:"p"},"total gas used")," by the ",Object(b.b)("inlineCode",{parentName:"p"},"unit of work"),"."),Object(b.b)("h4",{id:"mevbundle"},Object(b.b)("inlineCode",{parentName:"h4"},"MevBundle")),Object(b.b)("p",null,"An object with four properties:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:null},"Property"),Object(b.b)("th",{parentName:"tr",align:null},"Type"),Object(b.b)("th",{parentName:"tr",align:null},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"transactions")),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"Array<RLP(SignedTransaction)>")),Object(b.b)("td",{parentName:"tr",align:null},"A list of transactions in the bundle. Each transaction is signed and RLP-encoded.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"blockNumber")),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"uint64")),Object(b.b)("td",{parentName:"tr",align:null},"The exact block number at which the bundle can be executed")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"minTimestamp")),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"uint64")),Object(b.b)("td",{parentName:"tr",align:null},"Minimum block timestamp (inclusive) at which the bundle can be executed")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"maxTimestamp")),Object(b.b)("td",{parentName:"tr",align:null},Object(b.b)("inlineCode",{parentName:"td"},"uint64")),Object(b.b)("td",{parentName:"tr",align:null},"Maximum block timestamp (inclusive) at which the bundle can be executed")))),Object(b.b)("h3",{id:"bundle-construction"},"Bundle construction"),Object(b.b)("p",null,"Bundle ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD")," contain transactions with nonces that are following the current nonces of the signing addresses or other transactions preceding them in the same bundle."),Object(b.b)("p",null,"A bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," contain at least one transaction. There is no upper limit for the number of transactions in the bundle, however bundles that exceed the block gas limit will always be rejected. "),Object(b.b)("p",null,"A bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MAY")," include a ",Object(b.b)("inlineCode",{parentName:"p"},"direct coinbase payment")," or a ",Object(b.b)("inlineCode",{parentName:"p"},"contract coinbase payment"),". Bundles that do not contain such payments may lose comparison when their ",Object(b.b)("inlineCode",{parentName:"p"},"profit")," is compared with other bundles."),Object(b.b)("p",null,"The ",Object(b.b)("inlineCode",{parentName:"p"},"maxTimestamp")," value ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," be greater or equal the ",Object(b.b)("inlineCode",{parentName:"p"},"minTimestamp")," value."),Object(b.b)("h3",{id:"accepting-bundles-from-the-network"},"Accepting bundles from the network"),Object(b.b)("p",null,"Node ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," provide a way of exposing a JSON RPC endpoint accepting ",Object(b.b)("inlineCode",{parentName:"p"},"eth_sendBundle")," calls (specified ",Object(b.b)("a",{parentName:"p",href:"/flashbots-core/miners/mev-geth-spec/v01-rpc"},"here"),"). Such endpoint ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD")," only be accepting calls from ",Object(b.b)("inlineCode",{parentName:"p"},"MEV-relay")," but there is no requirement to restrict it through the node source code as it can be done on the infrastructure level."),Object(b.b)("h3",{id:"bundle-eligibility"},"Bundle eligibility"),Object(b.b)("p",null,"Any bundle that is correctly constructed ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," have a ",Object(b.b)("inlineCode",{parentName:"p"},"blockNumber")," field set which specifies in which block it can be included. If the node has already progressed to a later block number then such bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MAY")," be removed from memory."),Object(b.b)("p",null,"Any bundle that is correctly constructed ",Object(b.b)("inlineCode",{parentName:"p"},"MAY")," have a ",Object(b.b)("inlineCode",{parentName:"p"},"minTimestamp")," and/or a ",Object(b.b)("inlineCode",{parentName:"p"},"maxTimestamp")," field set. Default values for both of these fields are ",Object(b.b)("inlineCode",{parentName:"p"},"0")," and the meaning of ",Object(b.b)("inlineCode",{parentName:"p"},"0")," is that any block timestamp value is accepted. When these values are not ",Object(b.b)("inlineCode",{parentName:"p"},"0"),", then ",Object(b.b)("inlineCode",{parentName:"p"},"block.timestamp")," is compared with them. If the current ",Object(b.b)("inlineCode",{parentName:"p"},"block.timestamp")," is greater than the ",Object(b.b)("inlineCode",{parentName:"p"},"maxTimestamp")," then the bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MUST NOT")," be included in the block and ",Object(b.b)("inlineCode",{parentName:"p"},"MAY")," be removed from memory. If the ",Object(b.b)("inlineCode",{parentName:"p"},"block.timestamp")," is less than ",Object(b.b)("inlineCode",{parentName:"p"},"minTimestamp")," then the bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MUST NOT")," be included in the block and ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD NOT")," be removed from memory (it awaits future blocks)."),Object(b.b)("h3",{id:"block-construction"},"Block construction"),Object(b.b)("p",null,"A block ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," either contain one bundle or no bundles. When a bundle is included it ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," be the bundle with the highest ",Object(b.b)("inlineCode",{parentName:"p"},"adjusted gas price")," among eligible bundles. The node ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD")," be able to compare a ",Object(b.b)("inlineCode",{parentName:"p"},"block profit")," in cases when a bundle is included (MEV block) and when no bundles are included (regular block) and choose a block with the highest ",Object(b.b)("inlineCode",{parentName:"p"},"profit"),"."),Object(b.b)("p",null,"A block with a bundle ",Object(b.b)("inlineCode",{parentName:"p"},"MUST")," place the bundle at the beginning of the block and ",Object(b.b)("inlineCode",{parentName:"p"},"MUST NOT")," insert any transactions between the bundle transactions."),Object(b.b)("h3",{id:"bundle-eviction"},"Bundle eviction"),Object(b.b)("p",null,"Node ",Object(b.b)("inlineCode",{parentName:"p"},"SHOULD")," be able to limit the number of bundles kept in memory and apply an algorithm for selecting bundles to be evicted when too many eligible bundles have been received."),Object(b.b)("h2",{id:"rationale"},"Rationale"),Object(b.b)("h3",{id:"at-most-one-mevbundle-gets-included-in-the-block"},"At most one MevBundle gets included in the block"),Object(b.b)("p",null,"There are two reasons for which multiple bundles in a block may cause problems:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"two bundles may affect each other's ",Object(b.b)("inlineCode",{parentName:"li"},"profit")," and so the bundle creator may not be willing to accept a possibility of not being added in the front of the block"),Object(b.b)("li",{parentName:"ul"},"simulating multiple bundle combinations may be very straining for the node infrastructure and introduce excessive latency into the block creation process")),Object(b.b)("p",null,"Both of these problems may be addressed in the future versions."),Object(b.b)("h2",{id:"each-bundle-needs-a-blocknumber"},"Each bundle needs a blockNumber"),Object(b.b)("p",null,"This allows specifying bundles to be included in the future blocks (e.g. just after some smart contracts change their state). This cannot be used to ensure a specific parent block / hash."),Object(b.b)("h2",{id:"backwards-compatibility"},"Backwards Compatibility"),Object(b.b)("p",null,"This change is not affecting consensus and is fully backwards compatible."),Object(b.b)("h2",{id:"security-considerations"},"Security Considerations"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"MevBundles")," that are awaiting future blocks must be stored by the miner's node and it is important to ensure that there is a mechanism to ensure that the storage is limits are not exceeded (whether they are store in memory or persisted)."))}d.isMDXComponent=!0}}]);