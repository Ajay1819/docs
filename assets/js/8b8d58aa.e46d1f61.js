(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{111:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),b=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=b(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},p=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=b(n),p=r,h=d["".concat(i,".").concat(p)]||d[p]||u[p]||o;return n?a.a.createElement(h,s(s({ref:t},c),{},{components:n})):a.a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},92:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return b}));var r=n(3),a=n(7),o=(n(0),n(111)),i={title:"Ethers Provider - Flashbot-bundle"},s={unversionedId:"ethers-provider-flashbots-bundle",id:"ethers-provider-flashbots-bundle",isDocsHomePage:!1,title:"Ethers Provider - Flashbot-bundle",description:"Contains the FlashbotsBundleProvider ethers.js provider to provide high-level access to eth_sendBundle rpc endpoint on mev-relay.",source:"@site/docs/ethers-provider-flashbots-bundle.md",slug:"/ethers-provider-flashbots-bundle",permalink:"/docs/ethers-provider-flashbots-bundle",editUrl:"https://github.com/flashbots/docs/edit/main/docs/ethers-provider-flashbots-bundle.md",version:"current",sidebar:"docs",previous:{title:"Web3.py",permalink:"/docs/web3-flashbots"},next:{title:"Contribution guide",permalink:"/docs/contribution-guide"}},l=[{value:"Example",id:"example",children:[]},{value:"bundledTransactions",id:"bundledtransactions",children:[]},{value:"targetBlockNumber",id:"targetblocknumber",children:[]},{value:"FlashbotsTransactionResponse",id:"flashbotstransactionresponse",children:[]},{value:"How to run demo.ts",id:"how-to-run-demots",children:[]}],c={toc:l};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Contains the ",Object(o.b)("inlineCode",{parentName:"p"},"FlashbotsBundleProvider")," ethers.js provider to provide high-level access to ",Object(o.b)("inlineCode",{parentName:"p"},"eth_sendBundle")," rpc endpoint on ",Object(o.b)("a",{parentName:"p",href:"https://github.com/flashbots/mev-relay-js"},"mev-relay"),"."),Object(o.b)("p",null,"Flashbots-enabled relays and miners expose two new jsonrpc endpoint: ",Object(o.b)("inlineCode",{parentName:"p"},"eth_sendBundle")," and ",Object(o.b)("inlineCode",{parentName:"p"},"eth_callBundle"),". Since these are brand-new, non-standard endpoints, ethers.js and other libraries do not natively support these requests (like ",Object(o.b)("inlineCode",{parentName:"p"},"getTransactionCount"),"). In order to interact with these endpoints, you will also need access to another full-featured (non-Flashbots) endpoint for nonce-calculation, gas estimation, and transaction status."),Object(o.b)("p",null,"This library is not a fully functional ethers.js implementation, just a simple provider class, designed to interact with your existing ethers.js v5 module."),Object(o.b)("p",null,"You can pass in a generic ethers.js provider to the Flashbots provider in the constructor:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"const NETWORK_INFO = { chainId: 1, ensAddress: '', name: 'mainnet' }\n// Standard json rpc provider directly from ethers.js\nconst provider = new providers.JsonRpcProvider({ url: ETHEREUM_RPC_URL }, NETWORK_INFO)\n// `authSigner` is an Ethereum private key that does NOT store funds and is NOT your bot's primary key.\n// This is an identifying key for signing payloads to establish reputation and whitelisting\nconst authSigner = new Wallet('0x0000000000000000000000000000000000000000000000000000000000000000')\n// flashbots provider requires passing in a standard provider\nconst flashbotsProvider = await FlashbotsBundleProvider.create(provider, authSigner)\n")),Object(o.b)("p",null,"The flashbotsProvider provides the sendBundle function:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"flashbotsProvider.sendBundle(bundledTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>, targetBlockNumber: number)\n    => Promise<FlashbotsTransactionResponse>\n")),Object(o.b)("p",null,"and simulate function:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"flashbotsProvider.simulate(\n    signedBundledTransactions: Array<string>,\n    blockTag: BlockTag,\n    stateBlockTag?: BlockTag,\n    blockTimestamp?: number)\n      => Promise<SimulationResponse>\n")),Object(o.b)("h2",{id:"example"},"Example"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"// Using the map below ships two different bundles, targeting the next two blocks\nconst blockNumber = await provider.getBlockNumber()\nconst minTimestamp = (await provider.getBlock(blockNumber)).timestamp\nconst maxTimestamp = minTimestamp + 120\nconst bundlePromises = [blockNumber + 1, blockNumber + 2].map((targetBlockNumber) =>\n  flashbotsProvider.sendBundle(\n    [\n      {\n        signedTransaction: SIGNED_ORACLE_UPDATE_FROM_PENDING_POOL // serialized signed transaction hex\n      },\n      {\n        signer: wallet, // ethers signer\n        transaction: transaction // ethers populated transaction object\n      }\n    ],\n    targetBlockNumber, // block number at which this bundle is valid\n    {\n      minTimestamp, // optional minimum timestamp at which this bundle is valid (inclusive)\n      maxTimestamp // optional maximum timestamp at which this bundle is valid (inclusive)\n    }\n  )\n)\n")),Object(o.b)("h2",{id:"bundledtransactions"},"bundledTransactions"),Object(o.b)("p",null,"A Flashbots bundle consists of one or more transactions in strict order to be relayed to the miner directly. While the miner requires signed transactions, ",Object(o.b)("inlineCode",{parentName:"p"},"sendBundle()")," can receive a mix of pre-signed transaction and ",Object(o.b)("inlineCode",{parentName:"p"},"TransactionRequest")," + ",Object(o.b)("inlineCode",{parentName:"p"},"Signer")," (wallet) objects."),Object(o.b)("p",null,"These bundles can pay the miner either via gas fees ",Object(o.b)("em",{parentName:"p"},"OR")," via ",Object(o.b)("inlineCode",{parentName:"p"},"block.coinbase.transfer(minerReward)"),"."),Object(o.b)("h2",{id:"targetblocknumber"},"targetBlockNumber"),Object(o.b)("p",null,"The only block number for which the bundle is to be considered valid. If you would like more than one block to be targeted, submit multiple rpc calls targeting each specific block. This value should be higher than the value of getBlockNumber(). Submitting a bundle with a target block number of the current block, or earlier, is a no-op."),Object(o.b)("h2",{id:"flashbotstransactionresponse"},"FlashbotsTransactionResponse"),Object(o.b)("p",null,"A high-level object which contains metadata available at transaction submission time, as well as the following functions which can wait, track, and simulate the bundle's behavior."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"receipts() - Returns promise of an array of transaction receipts corresponding to the transaction hashes that were relayed as part of the bundle. Will not wait for block to be mined; could return incomplete information"),Object(o.b)("li",{parentName:"ul"},"wait() - Returns a promise which will wait for target block number to be reched ",Object(o.b)("em",{parentName:"li"},"OR")," one of the transactions to become invalid due to nonce-issues (including, but not limited to, one of the transactions from you bundle being included too early). Returns the wait resolution as a status enum"),Object(o.b)("li",{parentName:"ul"},"simulate() - Returns a promise of the transaction simulation, once the proper block height has been reached. Use this function to troubleshoot failing bundles and verify miner profitability")),Object(o.b)("h2",{id:"how-to-run-demots"},"How to run demo.ts"),Object(o.b)("p",null,"Included is a simple demo of how to construct the FlashbotsProvider with auth signer authentication and submit a ","[non-functional]"," bundle. This will not yield any mev, but could serve as a sample initialization to help integrate into your own functional searcher."))}b.isMDXComponent=!0}}]);